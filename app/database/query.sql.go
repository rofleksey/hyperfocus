// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package database

import (
	"context"
	"time"
)

const createStream = `-- name: CreateStream :exec
INSERT INTO streams(id, updated)
VALUES ($1, $2) ON CONFLICT (id) DO NOTHING
`

type CreateStreamParams struct {
	ID      string
	Updated time.Time
}

// CreateStream
//
//	INSERT INTO streams(id, updated)
//	VALUES ($1, $2) ON CONFLICT (id) DO NOTHING
func (q *Queries) CreateStream(ctx context.Context, arg CreateStreamParams) error {
	_, err := q.db.Exec(ctx, createStream, arg.ID, arg.Updated)
	return err
}

const getOnlineStreams = `-- name: GetOnlineStreams :many
SELECT id, updated, url, online, player_names
FROM streams
WHERE online = true
`

// GetOnlineStreams
//
//	SELECT id, updated, url, online, player_names
//	FROM streams
//	WHERE online = true
func (q *Queries) GetOnlineStreams(ctx context.Context) ([]Stream, error) {
	rows, err := q.db.Query(ctx, getOnlineStreams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Stream{}
	for rows.Next() {
		var i Stream
		if err := rows.Scan(
			&i.ID,
			&i.Updated,
			&i.Url,
			&i.Online,
			&i.PlayerNames,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSchemaVersion = `-- name: GetSchemaVersion :one
SELECT version
FROM schema_version
`

// GetSchemaVersion
//
//	SELECT version
//	FROM schema_version
func (q *Queries) GetSchemaVersion(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, getSchemaVersion)
	var version int32
	err := row.Scan(&version)
	return version, err
}

const searchStreamsByNickname = `-- name: SearchStreamsByNickname :many
SELECT id, updated, url, online, player_names
FROM streams
WHERE online = true
  AND EXISTS (SELECT 1
              FROM unnest(player_names) AS nickname
              WHERE levenshtein(lower(nickname), lower($1::VARCHAR(255))) < $2::INTEGER OR
                                                                                          lower(nickname) LIKE '%' ||
                                                                                                               lower($1::VARCHAR(255)) ||
                                                                                                               '%')
  LIMIT $3::INTEGER
`

type SearchStreamsByNicknameParams struct {
	Query      string
	Distance   int32
	MaxResults int32
}

// SearchStreamsByNickname
//
//	SELECT id, updated, url, online, player_names
//	FROM streams
//	WHERE online = true
//	  AND EXISTS (SELECT 1
//	              FROM unnest(player_names) AS nickname
//	              WHERE levenshtein(lower(nickname), lower($1::VARCHAR(255))) < $2::INTEGER OR
//	                                                                                          lower(nickname) LIKE '%' ||
//	                                                                                                               lower($1::VARCHAR(255)) ||
//	                                                                                                               '%')
//	  LIMIT $3::INTEGER
func (q *Queries) SearchStreamsByNickname(ctx context.Context, arg SearchStreamsByNicknameParams) ([]Stream, error) {
	rows, err := q.db.Query(ctx, searchStreamsByNickname, arg.Query, arg.Distance, arg.MaxResults)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Stream{}
	for rows.Next() {
		var i Stream
		if err := rows.Scan(
			&i.ID,
			&i.Updated,
			&i.Url,
			&i.Online,
			&i.PlayerNames,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setSchemaVersion = `-- name: SetSchemaVersion :exec
UPDATE schema_version
SET version = $1
`

// SetSchemaVersion
//
//	UPDATE schema_version
//	SET version = $1
func (q *Queries) SetSchemaVersion(ctx context.Context, version int32) error {
	_, err := q.db.Exec(ctx, setSchemaVersion, version)
	return err
}

const setStreamOnline = `-- name: SetStreamOnline :exec
UPDATE streams
SET online  = true,
    updated = $2
WHERE id = $1
`

type SetStreamOnlineParams struct {
	ID      string
	Updated time.Time
}

// SetStreamOnline
//
//	UPDATE streams
//	SET online  = true,
//	    updated = $2
//	WHERE id = $1
func (q *Queries) SetStreamOnline(ctx context.Context, arg SetStreamOnlineParams) error {
	_, err := q.db.Exec(ctx, setStreamOnline, arg.ID, arg.Updated)
	return err
}

const updateStaleStreams = `-- name: UpdateStaleStreams :exec
UPDATE streams
SET online = false
WHERE updated < $1
`

// UpdateStaleStreams
//
//	UPDATE streams
//	SET online = false
//	WHERE updated < $1
func (q *Queries) UpdateStaleStreams(ctx context.Context, updated time.Time) error {
	_, err := q.db.Exec(ctx, updateStaleStreams, updated)
	return err
}

const updateStreamData = `-- name: UpdateStreamData :exec
UPDATE streams
SET player_names = $2
WHERE id = $1
`

type UpdateStreamDataParams struct {
	ID          string
	PlayerNames []string
}

// UpdateStreamData
//
//	UPDATE streams
//	SET player_names = $2
//	WHERE id = $1
func (q *Queries) UpdateStreamData(ctx context.Context, arg UpdateStreamDataParams) error {
	_, err := q.db.Exec(ctx, updateStreamData, arg.ID, arg.PlayerNames)
	return err
}

const updateStreamUrl = `-- name: UpdateStreamUrl :exec
UPDATE streams
SET url = $2
WHERE id = $1
`

type UpdateStreamUrlParams struct {
	ID  string
	Url *string
}

// UpdateStreamUrl
//
//	UPDATE streams
//	SET url = $2
//	WHERE id = $1
func (q *Queries) UpdateStreamUrl(ctx context.Context, arg UpdateStreamUrlParams) error {
	_, err := q.db.Exec(ctx, updateStreamUrl, arg.ID, arg.Url)
	return err
}
